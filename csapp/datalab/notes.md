# datalab 解题思路

# 1. `bitXor`
> 实现`^`的逻辑

首先要清楚`^`做一些啥

| x^y |  0  |  1  |
| --- | --- | --- |
|  0  |  0  |  1  |
|  1  |  1  |  0  |

其次我们来观察题目给定的运算符`~`、`&`, 将解题思路往这两个运算符靠。

|  ~(x&y)   |  y=0  |  y=1  |
| --------- | ----- | ----- |
|    x=0    |   1   |   1   |
|    x=1    |   1   |   0   |

| ~(~x&~y)  |  y=0  |  y=1  |
| --------- | ----- | ----- |
|    x=0    |   0   |   1   |
|    x=1    |   1   |   1   |

这样上图的两个表的交集，刚好是我们要的答案
`(~(x&y))&(~(~x&~y))`

# 2. `tmin`
> 这道题考察补码的知识，一个数的最小值，应当首位为1即可

`int`有32位，所以将1左移31位即可

`1<<31`

# 3. `isTmax`
> 如果输入为最大数，即返回1，否则返回0

最大数的第一个特性就是，如果最大数+1，则溢出成为最小的数，两者之间的xor为`-1`
`0111`+1 => `1000`
而其他数
`0101`+1 => `0110`
`0001`+1 => `0010`

唯一特殊的是
`1111`+1 => `0000`，他们的xor也为`-1`

两者的差别在于
`一个加1等于-1`
`一个加1等于0`
==>
`!(((x+1)^x)+!!(x+1))`

当为最大数时，(x+1)^x ==> -1
!!(x+1) 为1
结果，为1
当为其他数时, (x+1)^x != -1
!!(x+1) 为0
结果，为0

当为-1时, (x+1)^x ==> -1
!!(x+1) 为0
结果，为0

# 4. `allOddBits`
> 输入数的奇数位都为1时，放回1，否者返回0

输入的`int`类型一共有32位
我们只需要遍历一遍就可以

即二进制`10101010` 和 `0xAA`取交集，结果应该也为`10101010`
> 注: 下标从0开始算起

`(x & 0xAA) & ((x >> 8) & 0xAA) & ((x >> 16) & 0xAA) & ((x >> 24) & 0xAA)`

如果结果符合预期，这个时候的值应该还是0xAA
最后我们需要通过`^`0xAA，如果不是这个数，那么结果应该非0

`!((x & 0xAA) & ((x >> 8) & 0xAA) & ((x >> 16) & 0xAA) & ((x >> 24) & 0xAA) ^ 0xAA)`

# 5. `negate`
> 考察对补码的定义

概念题, 原数取反+1则为相反数
`~x+1`

# 6. `isAsciiDigit`
> 需要寻找在[0x30, 0x39]区间内的数

即
  0x2f-x < 0
  x-0x3a < 0

((0x2f+(~x+1)) >> 31)
((~0x3a+1+x) >> 31)

`((0x2f+(~x+1)) >> 31)&((~0x3a+1+x) >> 31)`
当满足的时候，结果为-1
其他情况，结果都为0

所以答案为: `!!(((0x2f + (~x + 1)) >> 31) & ((~0x3a + 1 + x) >> 31))`

# 7. conditional
> 设计条件语句

首先要制造一个掩码
`~(!x)+1`

当为0的时候,这个值为-1

其他值时候，为0

`(mask & z) | (~mask & y)`

# 8. isLessOrEqual
> 判断数字大小

这要区分出两种情况

1. 当符号不同的时候，我们直接返回正数的
2. 当符号相同时候，我们需要进行第二次比较

首先看第一种情况下。我们先要判断出两者的符号不同

`int diff = (x >> 31) ^ (y >> 31)`

当符号不同时，我们只需要将x的符号返回就可以了
`x >> 31 & diff`
因为这个时候diff为-1，所以需要变成
`!!(x >> 31 & diff)`

这个时候我们还需要判断符号相同的时候的情况
即两者相减的情况
`((x+~y) >> 31)&(!diff)`

# 9. logicalNeg
> 实现`!`操作符

这题有点类似于第四题
我们只需要将所有的位都`|`一遍就可以

我们可以利用二分法快速的并集
`x = x | (x >> 16)`

最后将结果取反，和1取交集，结果就会是0或者1

# 10. howManyBits
> 获取数组所需要的空间

这个题首先是利用二分法，不断地累加
以8位为例子
`1000000`
首先需要将负数取反
`0111111`
然后取前4位看是否有1,并且取负数，构成掩码
`(~!(x>>4)) + 1`
然后决定是否加4
`sum += (~mask) & 4`
再通过掩码决定是左半边还是右半边
`x = ((~mask) & (x >> 16)) | ((mask & ((~(1 << 31)) >> 15)) & x)`

最后结果始终要有1位
`sum + 1 + (x&1)`

# 11. floatScale2
> 实现2*float

[wiki](https://zh.wikipedia.org/wiki/IEEE_754)

首先要拿到这个浮点数的`指数偏移值`(下文用`exp`代替),即表示2<sup>e</sup>的部分

`int exp = (uf & 0x7f800000) >> 23;`

首先我们要判断exp这部分为0，在这种情况下(非规则小数)，我们只要直接使尾数左移一位就可以

`if (exp == 0) return uf << 1 | sign;`

其次是exp全为1的情况, 以32位数来说，这个就是8为的exp，即最大值为255

`if (exp == 255) return uf;`

这个情况下，表示的是无穷大或者无穷小，所以直接返回原数即可

第三种情况是，规则小数，即exp不为0切不为255,这个时候，我们只需要将exp加1，就可以实现

`return  (++ exp) << 23 | (uf & 0x807fffff); `

# 12. floatFloat2Int
> 这个主要考察浮点数的定义

首先将`规则`/`非规则`/`特殊`，三种情况分开考虑

当为特殊时，直接返回`0x80000000u`,即`exp`为255时

当为非规则时，即无论如何都为0
但为规则是`e = exp - 127`(因为exp为0时)，这个数始终小于0，所以归纳到一起

即2<sup>e</sup> * 尾数
当e < 0时候，即，1<=尾数<2，所以始终会小于1
`return 0`

当 e < 23 时，即尾数不能全部包括住，所以需要右移`23-e`

当 e < 31 时，已经超过了int的范围(溢出)，所以返回`0x80000000u`

# 13. floatPower2
> 这道题主要考察规则小数的exp

要实现`2.0^x`，我们可以借助规则小数的exp段
这个地方本身表示为2<sup>127-exp</sup>
所以x =  127 - exp ==> exp = 127 + x

然后需要校验一下exp的区间范围,如果大于255，直接抛出INF
如果小于0，即exp的最小值也取值不到的范围，所以返回0

最后将exp放回位置，返回
`exp << 23`