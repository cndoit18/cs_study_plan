# datalab 解题思路

# 1. `bitXor`
> 实现`^`的逻辑

首先要清楚`^`做一些啥

| x^y |  0  |  1  |
| --- | --- | --- |
|  0  |  0  |  1  |
|  1  |  1  |  0  |

其次我们来观察题目给定的运算符`~`、`&`, 将解题思路往这两个运算符靠。

|  ~(x&y)   |  y=0  |  y=1  |
| --------- | ----- | ----- |
|    x=0    |   1   |   1   |
|    x=1    |   1   |   0   |

| ~(~x&~y)  |  y=0  |  y=1  |
| --------- | ----- | ----- |
|    x=0    |   0   |   1   |
|    x=1    |   1   |   1   |

这样上图的两个表的交集，刚好是我们要的答案
`(~(x&y))&(~(~x&~y))`

# 2. `tmin`
> 这道题考察补码的知识，一个数的最小值，应当首位为1即可

`int`有32位，所以将1左移31位即可

`1<<31`

# 3. `isTmax`
> 如果输入为最大数，即返回1，否则返回0

最大数的第一个特性就是，如果最大数+1，则溢出成为最小的数，两者之间的xor为`-1`
`0111`+1 => `1000`
而其他数
`0101`+1 => `0110`
`0001`+1 => `0010`

唯一特殊的是
`1111`+1 => `0000`，他们的xor也为`-1`

两者的差别在于
`一个加1等于-1`
`一个加1等于0`
==>
`!(((x+1)^x)+!!(x+1))`

当为最大数时，(x+1)^x ==> -1
!!(x+1) 为1
结果，为1
当为其他数时, (x+1)^x != -1
!!(x+1) 为0
结果，为0

当为-1时, (x+1)^x ==> -1
!!(x+1) 为0
结果，为0

# 4. `allOddBits`
> 输入数的奇数位都为1时，放回1，否者返回0

输入的`int`类型一共有32位
我们只需要遍历一遍就可以

即二进制`10101010` 和 `0xAA`取交集，结果应该也为`10101010`
> 注: 下标从0开始算起

`(x & 0xAA) & ((x >> 8) & 0xAA) & ((x >> 16) & 0xAA) & ((x >> 24) & 0xAA)`

如果结果符合预期，这个时候的值应该还是0xAA
最后我们需要通过`^`0xAA，如果不是这个数，那么结果应该非0

`!((x & 0xAA) & ((x >> 8) & 0xAA) & ((x >> 16) & 0xAA) & ((x >> 24) & 0xAA) ^ 0xAA)`

# 5. `negate`
> 考察对补码的定义

概念题, 原数取反+1则为相反数
`~x+1`

# 6. `isAsciiDigit`
> 需要寻找在[0x30, 0x39]区间内的数

即
  0x2f-x < 0
  x-0x3a < 0

((0x2f+(~x+1)) >> 31)
((~0x3a+1+x) >> 31)

`((0x2f+(~x+1)) >> 31)&((~0x3a+1+x) >> 31)`
当满足的时候，结果为-1
其他情况，结果都为0

所以答案为: `!!(((0x2f + (~x + 1)) >> 31) & ((~0x3a + 1 + x) >> 31))`

# 7. conditional
> 设计条件语句

首先要制造一个掩码
`~(!x)+1`

当为0的时候,这个值为-1

其他值时候，为0

`(mask & z) | (~mask & y)`